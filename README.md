# Contents

### 目录
### Contents

### 第一部分 前端工程化管理工具
**01 安装机制及企业级部署私服原理** - 2
- npm内部机制与核心原理 - 2
- npm不完全指南 - 6
- npm多源镜像和企业级部署私服原理 - 9
- 总结 - 11

**02 Yarn安装理念及依赖管理困境破解** - 12
- Yarn的安装机制和背后思想 - 14
- 破解依赖管理困境 - 17
- 总结 - 21

**03 CI环境下的npm优化及工程化问题解析** - 22
- CI环境下的npm优化 - 22
- 更多工程化相关问题解析 - 22
- 最佳实操建议 - 22
- 总结 - 22

**04 主流构建工具的设计考量** - 22
- 从Tooling.Report中，我们能学到什么 - 22
- 总结 - 22

**05 Vite实现：源码分析与工程构建** - 22
- Vite的“横空出世” - 22
- Vite实现原理解读 - 22
- 总结 - 22

### 第二部分 现代化前端开发和架构生态
**06 谈谈core - js及polyfill理念** - 52
- core - js工程一览 - 52
- 如何复用一个polyfill - 52
- 寻找最佳的polyfill方案 - 54
- 总结 - 59

**07 梳理混乱的Babel，拒绝编译报错** - 62
- Babel是什么 - 62
- Babel Monorepo架构包解析 - 63
- Babel工程生态架构设计和分层理念 - 63
- 总结 - 64

**08 前端工具链：统一标准化的babel - preset** - 79
- 从公共库处理的问题，谈如何做好“扫雷人” - 79
- 应用项目构建和公共库构建的差异 - 79
- 一个企业级公共库的设计原则 - 81
- 制定一个统一标准化的babel - preset - 81
- 总结 - 82

**09 从0到1构建一个符合标准的公共库** - 91
- 实战打造一个公共库 - 92
- 打造公共库，支持script标签引入代码 - 96
- 打造公共库，支持Node.js环境 - 100
- 从开源库总结生态设计 - 103
- 总结 - 104

**10 代码拆分与按需加载** - 105
- 代码拆分与按需加载的应用场景 - 105
- 代码拆分与按需加载技术的实现 - 105
- Webpack赋能代码拆分和按需加载 - 105
- 总结 - 105

**11 Tree Shaking：移除JavaScript上下文中的未引用代码** - 105
- Tree Shaking必会理论 - 105
- 前端工程化生态和Tree Shaking实践 - 105
- 总结 - 105

**12 理解AST实现和编译原理** - 132
- AST基础知识 - 132
- AST实战：实现一个简易Tree Shaking脚本 - 132
- 总结 - 132

**13 工程化思维：应用主题切换** - 14
- 设计一个主题切换工程架构 - 14
- 主题色切换架构实现 - 14
- 总结 - 15

**14 解析Webpack源码，实现工具构建** - 15
- Webpack的初心和奥秘 - 15
- 手动实现打包器 - 15
- 总结 - 15

**15 跨端解析小程序多端方案** - 16
- 小程序多端方案概览 - 16
- 小程序多端——编译时方案 - 16
- 小程序多端——运行时方案 - 16
- 小程序多端——类React风格的编译时和运行时结合方案 - 16
- 小程序多端方案的优化 - 16
- 总结 - 16

**16 从移动端跨平台到Flutter的技术变革** - 179
- 移动端跨平台技术原理和变迁 - 179
- Flutter新贵背后的技术变革 - 179
- 总结 - 188

### 第三部分 核心框架原理与代码设计模式
**17 axios：封装一个结构清晰的Fetch库** - 196
- 设计请求库需要考虑哪些问题 - 196
- axios设计之美 - 199
- 总结 - 206

**18 对比Koa和Redux：解析前端中间件** - 207
- 以Koa为代表的Node.js中间件设计 - 207
- 对比Express，再谈Koa中间件 - 210
- Redux中间件设计和实现 - 210
- 利用中间件思想，实现一个中间件化的Fetch库 - 210
- 总结 - 210

**19 软件开发灵活性和高定制性** - 210
- 设计模式 - 210
- 函数式思想应用 - 210
- 总结 - 210

**20 理解前端中的面向对象思想** - 210
- 实现new没有那么容易 - 210
- 如何优雅地实现继承 - 210
- jQuery中的面向对象思想 - 210
- 类继承和原型继承的区别 - 210
- 总结 - 210

**21 利用JavaScript实现经典数据结构** - 210
- 数据结构简介 - 210
- 堆栈和队列 - 210
- 链表（单向链表和双向链表） - 210
- 树 - 210
- 图 - 210
- 总结 - 210

**22 剖析前端数据结构的应用场景** - 210
- 堆栈和队列的应用 - 210
- 链表的应用 - 210
- 树的应用 - 210
- 总结 - 210

### 第四部分 前端架构设计实战
**23 npm scripts：打造一体化构建和部署流程** - 266
- npm scripts是什么 - 266
- npm scripts原理 - 266
- npm scripts使用技巧 - 267
- 打造一个lucas - scripts - 270
- 总结 - 276

**24 自动化代码检查：剖析Lint工具** - 277
- 自动化工具 - 277
- lucas - scripts中的Lint配置最佳实践 - 281
- 工具背后的技术原理和设计 - 283
- 总结 - 285

**25 前端+移动端离线包方案设计** - 286
- 从流程图分析hybrid性能痛点 - 286
- 相应优化策略 - 287
- 离线包方案 - 288
- 方案持续优化 - 289
- 总结 - 289

**26 设计一个“万能”的项目脚手架** - 289
- 命令行工具的原理和实现 - 289
- 从命令行到万能脚手架 - 289
- 总结 - 289

### 第五部分 前端全链路——Node.js全栈开发
**27 同构渲染架构：实现SSR应用** - 289
- 实现一个简易的SSR应用 - 289
- SSR应用中容易忽略的细节 - 289
- 总结 - 289

**28 性能守卫系统设计：完善CI/CD流程** - 289
- 性能守卫理论基础 - 289
- Lighthouse原理介绍 - 289
- 性能守卫系统Perf - patronus - 289
- 总结 - 289

**29 打造网关：改造企业BFF方案** - 289
- BFF网关介绍和优缺点梳理 - 289
- 打造BFF网关需要考虑的问题 - 289
- 实现一个lucas - gateway - 289
- 总结 - 289

**30 实现高可用：Puppeteer实战** - 341
- Puppeteer简介和原理 - 341
- Puppeteer在SSR中的应用 - 341
- Puppeteer在UI测试中的应用 - 342
- Puppeteer结合Lighthouse的应用场景 - 345
- 通过Puppeteer实现海报Node.js服务 - 347
- 总结 - 353 
