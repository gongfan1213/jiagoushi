### 25 前端+移动端离线包方案设计
NSR（Native Side Rendering，客户端离线包渲染）方案是前端和客户端配合的典型案例。在本篇中，我们将详细分析一个前端+移动端离线包方案的设计思路。

当然，设计离线包方案并不是终极目的，通过离线包方案的源起和落地，我们也会梳理整个Hybrid页面的相关优化方案。

#### 从流程图分析Hybrid性能痛点
简单来说，离线包是解决性能问题、提升Hybrid页面可用性的重要方案。Hybrid页面性能具有一定的特殊性，因为它是客户端和前端的衔接，因此性能较为复杂。我们从加载一个Hybrid页面的流程来分析，如图25-1所示。

参考图25-1，在一个原生页面上点击按钮，打开一个Hybrid页面，首先经过原生页面路由识别到“正在访问一个Hybrid页面”，此时会启动一个WebView容器，接着进入一个正常的前端CSR渲染流程：首先请求并加载HTML，接着以HTML为起点加载JavaScript、CSS等静态资源，并通过JavaScript发送数据请求，最终完成页面内容的渲染。

整个路径分成了两阶段：客户端阶段、前端阶段。每个单一阶段都有多种优化方法，比如对于WebView容器的启动，客户端可以提前启动WebView容器池，这样在真正访问Hybrid页面时可以复用已储备好的WebView容器。再比如，前端渲染架构可以从CSR切换到SSR，这样在一定程度上能保证首屏页面的直出，获得更好的FMP、FCP时间。

![image](https://github.com/user-attachments/assets/cfe3503c-8d59-4466-be33-884efd93fb58)


#### 相应优化策略
我们结合图25-2，简单总结一下上述流程中能够做到的优化策略。

![image](https://github.com/user-attachments/assets/fad64e85-b550-471f-91f7-adc36fae47e7)


**前端业务层**：

- **静态资源瘦身**：将JavaScript和CSS等静态资源进行充分压缩，或实施合理的分割策略，有效地减少对于静态资源的网络请求时间、响应脚本解析时间等。
- **静态数据占位**：使用静态数据预先填充页面，使得页面能够更迅速地呈现内容，并在数据请求成功后加载真实数据。
- **静态资源缓存**：常用的工程手段，合理缓存静态资源可减少网络I/O，提升性能。
- **服务器端渲染（SSR）**：前面提到过，SSR可以直出带有数据的首屏页面，有效优化FMP、FCP等指标。
- **骨架屏**：广义的骨架屏甚至包括Loading Icon在内，这其实是一种提升用户体验的关键手段。在内容渲染完成之前，我们可以加载一段表意内容的Icon或占位区块placeholder，帮助用户缓解焦虑的心理，营造一种“页面加载渲染足够快”的感觉。
- **首屏分屏或按需渲染**：这种手段和静态资源瘦身有一定关系。我们将非关键的内容延迟按需渲染，而不是在首次加载渲染时就一并完成，这样可以优先保证视口内的内容展现。
- **关键路径优化**：关键路径优化，是指页面在渲染内容完成前必须先完成的步骤。对于关键路径的优化，其实前面几点已经涵盖了。

从HTML、JavaScript、CSS字节到将内容渲染至屏幕上的流程，如图25-3所示。
- 解析HTML并构建DOM。
- 并行解析CSS并构建CSSOM。
- 将DOM与CSSOM合成为Render tree。
- 根据Render tree合成Layout，完成绘制。

![image](https://github.com/user-attachments/assets/c30c21ed-d078-44a4-a3f9-841ad4345464)


由上述流程可以总结出，优化关键为：减少关键资源的数量；缩小关键资源的体积；优化关键资源的加载顺序，充分并行化。

接下来我们再来看看客户端容器层的优化方案，大概如下。
- **容器预热**。
- **数据预取**。
- **跨栈数据传递**。
- **小程序化**。

其中，小程序化能够充分利用客户端开发的性能优势，但与主题不相关，我们暂且不讨论。容器预热和数据预取也是常规的优化手段，其本质都是“抢跑”。

离线包方案主要属于通用层优化策略，接下来我们进入离线包方案的设计环节。

#### 离线包方案的设计流程
自从UC团队在GMTIC2019全球大前端技术大会上提到0.3s的“闪开方案”以来，很多团队已经将离线包方案落地并将其发扬光大。事实上，该方案的提出可以追溯到更早的时候。其核心思路是：客户端提前下载好HTML模板，在用户交互时，由客户端完成数据请求并渲染HTML，最终交给WebView容器加载。

换句话说，以离线包方案为代表的NSR，就是客户端版本的SSR。各个团队可能在实现思路的细节上有所不同，但主要流程大同小异，如图25-4所示。

![image](https://github.com/user-attachments/assets/59fc38df-8b32-42a5-ba22-f0a2d72567b7)


根据图25-4，我们总结出离线包方案的基本实现流程，如下。
- 用户打开Hybrid页面。
- 在原生客户端路由阶段，判断离线包版本是否可用。
    - 如果内置的离线包版本不可用或已经落后线上版本，则进入在线流程，即正常启动WebView，由前端加载渲染页面。
    - 如果内置的离线包版本可用，则进入离线流程。完成以下操作后，客户端将执行权和必要数据交给前端，由WebView完成页面的渲染。
        - 客户端并行加载本地模板。
        - 客户端并行请求业务接口。
        - 客户端启动WebView。

整个流程简单清晰，但有几个主要问题需要我们思考。
- 如何检测离线包版本，如何维护离线包？
- 如何生成离线包模板？
- 客户端如何“知道”页面需要请求哪些业务数据？

#### 离线包服务平台
关于上述第一个问题——如何检测离线包版本，如何维护离线包？这是一个可大可小的话题。简单来说，可以由开发者手动打出离线包，并将其内置在应用包中，随着客户端发版进行更新。但是这样做的问题也非常明显。
- 更新周期太慢，需要和客户端发版绑定。
- 手动流程过多，不够自动化、工程化。

一个更合理的方式是实现“离线包平台”，该平台需要提供以下服务。
1. **提供离线包获取服务**

获取离线包可以考虑主动模式和被动模式。被动模式下，需要开发者将构建好的离线包手动上传到离线包平台。主动模式则更为智能，可以绑定前端CI/CD流程，在每次发版上线时自动完成离线包构建，构建成功后由CI/CD环节主动请求离线包接口，将离线包推送到离线平台。

2. **提供离线包查询服务**

提供一个HTTP服务，该服务用于离线包状态查询。比如，在每次启动应用时，客户端查询该服务，获取各个业务离线包的最新稳定版本，客户端以此判断是否可以应用本地离线包资源。

3. **提供离线包下发服务**
   
提供一个HTTP服务，可以根据各个离线包版本的不同下发离线包，也可以将离线包内静态资源完全扁平化，进行增量下发。需要注意的是，扁平化增量下发可以较大限度地使用离线包资源。比如某次离线包版本构建过程中，v2和v1两个版本比较可能会存在较多没有变化的静态资源，此时就可以复用已有的静态资源，减少带宽和存储压力。

整体的离线包服务平台可以抽象为图25-5。

![image](https://github.com/user-attachments/assets/4256b79e-d59d-4dfa-a068-4158d4b8e369)



离线包服务平台按照版本不同整体下发资源的流程如图25-6所示。


![image](https://github.com/user-attachments/assets/3280d0b4-0034-4455-9ad6-13cb4bce19e1)


离线包服务平台进行扁平化增量下发资源的流程如图25-7所示。

![image](https://github.com/user-attachments/assets/4a7196bb-2ccb-4e82-aeb4-842c4904caf3)


#### 离线包构建能力
了解了离线包服务平台，我们再思考一个问题：如何构建一个离线包呢？

以“客户端发送数据请求”的离线包方案为例，既然数据请求需要由客户端发出，那么离线包资源就需要声明“该页面需要哪些数据请求”。因此，离线包中需要一个json文件用于配置声明。
```json
// 一个描述离线包配置声明的.json文件appConfig.json
{
    "appid": "XXX",
    "name": "template1",
    "version": "2020.1204.162513",
    "author": "xxxx",
    "description": "XXX页面",
    "check_integrity": true,
    "home": "https://www.XXX.com/XXX",
    "host": {"online":"XXX.com"},
    "scheme": {"android":{"online":"https"},
    "iOS":{"online":"resource"}},
    "expectedFiles":["1.js","2.js","1.css","2.css","index.html"],
    "created_time":1607070313,
    "sdk_min":"1.0.0",
    "sdk_max":"2.0.0",
    "dataApi": ["xxxx"]
}
```

上面的appConfig.json描述了该离线包的关键信息，比如dataApi表明业务所需要的数据接口。 


一般这里可以放置首屏关键请求，由客户端发出这些请求并由template渲染。appid表明了该业务ID，expectedFiles表明了该业务所需的离线包资源，这些资源一并内置于离线包当中。

对于expectedFiles声明的资源，依然可以通过Webpack等构建工具打包。我们可以通过编写一个Webpack插件来获取dataApi字段内容，当然初期也可以由开发者手动维护该字段。

### 离线包方案持续优化
上述内容基本已经囊括了一个离线包方案的设计流程，但是一个工程方案还需要考虑更多的细节。下面我们来对更多优化点进行分析。

#### 离线包可用性和使用命中率
试想，如果业务迭代频繁，离线包也会迭代频繁，可用离线包的命中率就会降低，效果上会打折扣。同时离线包的下载以及解压过程也可能会出现错误，导致离线包不可用。

为此，一般的做法是采用重试和定时轮询机制。在网络条件允许的情况下，为了减少网络原因导致的离线包不可用，我们可以设置最大重试次数，并设定15s或一定时间的间隔，进行离线包下载重试。

为了防止移动运营商的劫持，我们还需要保证离线包的完整性，即检查离线包文件是否被篡改过。一般在下发离线包时要同时下发文件签名，离线包下载完成后由客户端进行签名校验。

另外，定时轮询机制能够定时到离线包服务平台拉取最新版本的离线包，这样能够防止离线包下载不及时，是对“仅在App启动时加载离线包”策略的很好补充。当然，你也可以让服务器端主动推送离线包，但是该方案成本较高。

#### 离线包安全性考量
离线包方案从本质上改变了传统Hybrid页面加载和渲染技术较为激进的弊端，我们需要从各方面考量离线包的安全性。一般可以设计灰度发布状态，即在全量铺开某离线包前先进行小流量测试，观察一部分用户的使用情况。

另外，还要建立健全的fallback机制，在发现当前最新版本的离线包不可用时，迅速切换到稳定可用的版本，或者回退到线上传统机制。

实际情况中，我们总结了需要使用fallback机制的情况，包括但不限于以下三种。
- 离线包解压缩失败。
- 离线包服务平台接口连接超时。
- 使用增量diff时，资源合并失败。

#### 用户流量考量
为了减少每次下载或更新离线包时对流量的消耗，可以使用增量更新机制。一种思路是在客户端根据hash值进行增量更新，另一种思路是在利用diff时根据文件更改进进行增量包设计。

我们也可以在具体文件内容层面进行diff操作，具体策略是使用Node.js的bsdiff/bspatch二进制差量算法工具包bsdp，但bsdiff算法产出的结果往往也会受到压缩包压缩等级和压缩包修改内容的影响，且patch包的生成具有一定的风险，可以按照业务和团队的实际情况进行选型。

另外，还有一些优化手段值得一提。

- 离线包资源的核心静态文件可以和图片等富媒体资源文件分离缓存，这样可以更方便地管理缓存，且离线包核心静态资源也可以整体被提前加载进内存，减少磁盘I/O耗时。
- 使用离线包之后是否会对现有的A/B测试策略、数据打点策略有影响？离线包渲染后，在用户真实访问之前，我们是不是能够将预创建页面的UV、PV、数据曝光等埋点进行上报的，否则会干扰正常的数据统计。
- HTML文件是否应该作为离线包资源的一部分？在目前的主流方案中，很多方案也将HTML文件作为离线包资源的一部分。另一种方案是只缓存JavaScript、CSS文件，而HTML文件还需要使用在线策略。

### 总结
本篇分析了在加载一个Hybrid页面的过程中，前端业务层、容器层、通用层的优化策略，并着重分析了离线包方案的设计和优化。

性能优化是一个宏大的话题，我们不仅需要在前端领域进行性能优化，还要有更高的视角，在业务全链路上追求性能最优。离线包方案是一个典型的例子，它突破了传统狭隘前端需要各个业务团队协调配合的现状，我们要认真掌握。 
