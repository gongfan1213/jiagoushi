### 04 主流构建工具的设计考量

现代化前端架构离不开构建工具的加持。对构建工具的理解、选择和应用决定了我们是否能够打造一个使用流畅且接近完美的产品。

提到构建工具，作为经验丰富的前端开发者，相信你一定能列举出不同时代的代表：从Browserify + Gulp到Parcel，从Webpack到Rollup，甚至Vite，相信你都不陌生。没错，前端发展到现在，构建工具琳琅满目且成熟稳定。但这些构建工具的实现和设计非常复杂，甚至出现了“面向构建工具编程”的调侃。

事实上，能够熟悉并精通构建工具的开发者凤毛麟角。请注意，这里的“熟悉并精通”并不是要求你对不同构建工具的配置参数如数家珍，而是真正把握构建流程。在“6个月就会出现一股新的技术潮流”的前端领域，能始终把握构建工具的奥秘，这是区分资深架构师和程序员的一个重要标志。

如何真正了解构建流程，甚至能够自己开发一个构建工具呢？在本篇中，我们通过“横向对比构建工具”这个新颖的角度，来介绍构建工具背后的架构理念。

#### 从Tooling.Report中，我们能学到什么
Tooling.Report是由Chrome core team核心成员及业内著名开发者打造的构建工具对比平台。这个平台对比了Webpack、Rollup、Parcel、Browserify在不同维度下的表现，如图4 - 1所示。

我们先来看看评测数据：Rollup得分最高，Parcel得分最低，Webpack和Rollup得分接近。测评得分只是一个方面，实际表现也和不同构建工具的设计目标有关。

比如，Webpack构建主要依赖插件和loader，因此它的能力虽然强大，但配置信息较为烦琐。Parcel的设计目标之一就是零配置、开箱即用，但在功能的集成上相对有限。

从横向发展来看，各大构建工具之间也在互相借鉴发展。比如，以Webpack为首的工具编译速度较慢，即便启动增量构建也无法解决初始时期构建时间过长的问题。而Parcel内置了多核并行构建能力，利用多线程实现编译，在初始构建阶段就能获得较理想的构建速度。同时，Parcel还内置了文件系统缓存能力，可以保存每个文件的编译结果。在这一方面，Webpack新版本（v5）也有相应跟进。

因此，在构建工具的横向对比上，功能是否强大是一方面，构建效率也是开发者需要考虑的核心指标。

那么对于构建工具来说，在一个现代化的项目中，哪些功能是“必备”的呢？从这些功能上，我们能学到哪些基建和工程化知识呢？

还是以上面的评测分数为例，这些分数来自6个维度，如图4 - 2所示。

在code splitting方面，Rollup表现最好，这是Rollup现代化的一个重要体现，而Browserify表现最差。在hashing、importing modules及transformation方面，各大构建工具表现相对趋近。在output module formats上，除了Browserify，其他工具表现相对一致。

这里需要深入思考：这6个维度到底是什么，为什么它们能作为评测标准？实际上，这个问题反映的技术信息是，一个现代化构建工具或构建方案需要重点考量/实现哪些环节。下面我们针对这6个维度逐一进行分析。

##### code splitting
code splitting，即代码分割。这意味着在构建打包时要导出公共模块，避免重复打包，以及在页面加载运行时实现最合理的按需加载策略。

实际上，code splitting是一个很宽泛的话题，其中的问题包括：不同模块间的代码分割机制能否支持不同的上下文环境（Web worker环境等特殊上下文）；如何实现对动态导入语法特性的支持；应用配置多入口/单入口是否支持重复模块的抽取及打包；代码模块间是否支持Living Bindings（如果被依赖的模块中的值发生了变化，则会映射到所有依赖该值的模块中）。

code splitting是现代化构建工具的标配，因为它直接决定了前端的静态资源产出情况，影响着项目应用的性能表现。

##### hashing
hashing，即对打包资源进行版本信息映射。这个话题背后的重要技术点是最大化利用缓存机制。我们知道，有效的缓存策略将直接影响页面加载表现，决定用户体验。那么对于构建工具来说，为了实现更合理的hash机制，构建工具就需要分析各种打包资源，导出模块间的依赖关系，依据依赖关系上下文决定产出包的hash值。因为一个资源的变动会引起其依赖下游的关联资源的变动，因此构建工具进行打包的前提就是对各个模块的依赖关系进行分析，并根据依赖关系支持开发者自定义hash策略。

这就涉及一个知识点：如何区分Webpack中的hash、chunkhash、contenthash？

hash反映了项目的构建版本，因此同一次构建过程中生成的hash值都是一样的。换句话说，如果项目里的某个模块发生了改变，触发了项目重新构建，那么文件的hash值将会相应改变。

但使用hash策略会存在一个问题：即使某个模块的内容压根没有改变，重新构建后也会产生一个新的hash值，使得缓存命中率较低。

针对以上问题，chunkhash和contenthash的情况就不一样了。chunkhash会根据入口文件（Entry）进行依赖解析，contenthash则会根据文件具体内容生成hash值。

我们来具体分析，假设应用项目做到了将公共库和业务项目入口文件区分开单独打包，则采用chunkhash策略时，改动业务项目入口文件，不会引起公共库的hash值改变，对应示例如下。
```javascript
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react']
},
output:{
    path:path.join(__dirname,'./build'),
    publicPath: '/build/',
    filename: 'bundle.[chunkhash].js'
}
```

我们再看一个例子，在index.js文件中对index.css进行引用，如下。
```javascript
require('./index.css')
```

此时，因为index.js文件和index.css文件具有依赖关系，所以它们共用相同的chunkhash值。如果index.js文件内容发生变化，即使index.css中内容没有改动，在使用chunkhash策略时，被单独拆分的index.css的hash值也发生了变化。如果想让index.css完全根据文件内容来确定hash值，则可以使用contenthash策略。

##### importing modules
importing modules，即依赖机制。它对于一个构建流程或工具来说非常重要，因为历史和设计原因，前端开发者一般要面对包括ESM、CommonJS等在内的不同模块化方案。而一个构建工具在设计时自然就要兼容不同类型的importing modules方案。除此之外，由于Node.js的npm机制，构建工具也要支持从node_modules引入公共包。

##### non - JavaScript resources
non - JavaScript resources是指导入其他非JavaScript类型资源的支持。这里的资源可以是HTML文档、CSS样式资源、JSON资源、富媒体资源等。这些资源也是构成一个应用的关键内容，构建流程和工具当然要对此支持。

##### output module formats
output module formats即输出模块化，对应importing modules，构建输出内容的模块化方式需要更加灵活，比如，开发者可配置符合ESM、CommonJS等规范的构建内容导出机制。

##### transformations
transformations即编译，现代化前端开发离不开编译、转义过程。比如对JavaScript代码的压缩、对未引用代码的删除（DCE）等。这里需要注意的是，我们在设计构建工具时，对类似JSX、Vue.js等文件的编译不会内置到构建工具中，而是利用Babel等社区能力将该功能“无缝融合”到构建流程中。构建工具只做分内的事情，其他扩展能力需通过插件化机制来完成。

以上6个维度都能展开作为一个独立且丰富的话题深入讨论。设计这些内容是因为，我希望你能从大局观上对构建流程和构建工具要做哪些事情，以及为什么要做这些事情有一个更清晰的认知。

#### 总结
本篇我们从Tooling.Report入手，根据其集成分析的结果，横向对比了各大构建工具。其实对比只是一方面，更重要的是通过对比结果了解各个构建工具的功能，以及基础建设和工程化要考虑的内容。搞清楚这些，我们就能以更广阔的视角进行技术选型，审视基础建设和工程化。 
